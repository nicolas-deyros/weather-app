---
import { Icon } from 'astro-icon/components'
---

<div class="mb-8 rounded-2xl bg-white/10 p-6 backdrop-blur-lg">
	<div class="flex flex-col space-y-4">
		<!-- Search Input -->
		<div class="relative">
			<input
				type="text"
				id="locationSearch"
				placeholder="Search for a city (e.g., New York, London, Tokyo...)"
				class="w-full rounded-lg border border-white/30 bg-white/20 px-4 py-3 pr-12 text-white placeholder-blue-200 focus:border-white/60 focus:ring-2 focus:ring-white/20 focus:outline-none"
			/>
			<button
				id="searchButton"
				class="absolute top-1/2 right-2 -translate-y-1/2 transform rounded-md bg-blue-600 p-2 text-white transition-colors hover:bg-blue-700"
				title="Search location">
				<svg
					class="h-4 w-4"
					fill="none"
					stroke="currentColor"
					viewBox="0 0 24 24">
					<path
						stroke-linecap="round"
						stroke-linejoin="round"
						stroke-width="2"
						d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z">
					</path>
				</svg>
			</button>
		</div>

		<!-- Geolocation Button -->
		<div class="flex justify-center">
			<button
				id="geolocationButton"
				class="flex items-center space-x-2 rounded-lg bg-green-600 px-4 py-2 text-white transition-colors hover:bg-green-700"
				title="Use current location">
				<Icon name="nrk:geo" size={20} />
				<span>Use My Location</span>
			</button>
		</div>

		<!-- Loading State -->
		<div id="loadingState" class="hidden text-center">
			<div class="flex items-center justify-center space-x-2 text-blue-200">
				<div class="h-4 w-4 animate-spin rounded-full border-b-2 border-white">
				</div>
				<span>Searching...</span>
			</div>
		</div>

		<!-- Error Message -->
		<div
			id="errorMessage"
			class="hidden rounded-lg border border-red-500/30 bg-red-500/20 p-3">
			<p class="text-sm text-red-200"></p>
		</div>

		<!-- Location Result -->
		<div
			id="locationResult"
			class="hidden rounded-lg border border-blue-500/30 bg-blue-500/20 p-4">
			<h4 class="mb-2 font-semibold text-white">Location Found:</h4>
			<div class="space-y-1 text-sm text-blue-100">
				<div><strong>City:</strong> <span id="resultCity">-</span></div>
				<div><strong>Country:</strong> <span id="resultCountry">-</span></div>
				<div><strong>Latitude:</strong> <span id="resultLat">-</span></div>
				<div><strong>Longitude:</strong> <span id="resultLon">-</span></div>
			</div>
			<button
				id="useLocationButton"
				class="mt-3 rounded-lg bg-blue-600 px-4 py-2 text-sm text-white transition-colors hover:bg-blue-700">
				Get Weather for This Location
			</button>
		</div>
	</div>
</div>

<script>
	// TypeScript interfaces
	interface LocationResult {
		city: string
		country: string
		lat: number
		lon: number
		full_name: string
	}

	// Geocoding function using OpenStreetMap Nominatim API
	async function searchLocation(query: string) {
		try {
			const response = await fetch(
				`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&addressdetails=1`,
			)
			const data = await response.json()

			if (data && data.length > 0) {
				const location = data[0]
				return {
					city: location.display_name.split(',')[0],
					country: location.address?.country || 'Unknown',
					lat: parseFloat(location.lat),
					lon: parseFloat(location.lon),
					full_name: location.display_name,
				}
			} else {
				throw new Error('Location not found')
			}
		} catch {
			throw new Error('Failed to search location')
		}
	}

	// Reverse geocoding function
	async function reverseGeocode(lat: number, lon: number) {
		try {
			const response = await fetch(
				`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`,
			)
			const data = await response.json()

			if (data) {
				return {
					city:
						data.address?.city ||
						data.address?.town ||
						data.address?.village ||
						'Unknown',
					country: data.address?.country || 'Unknown',
					lat: lat,
					lon: lon,
					full_name: data.display_name,
				}
			} else {
				throw new Error('Location not found')
			}
		} catch {
			throw new Error('Failed to get location details')
		}
	}

	// Show/hide elements
	function showLoading() {
		document.getElementById('loadingState')?.classList.remove('hidden')
		document.getElementById('errorMessage')?.classList.add('hidden')
		document.getElementById('locationResult')?.classList.add('hidden')
	}

	function hideLoading() {
		document.getElementById('loadingState')?.classList.add('hidden')
	}

	function showError(message: string) {
		hideLoading()
		const errorEl = document.getElementById('errorMessage')
		if (errorEl) {
			errorEl.classList.remove('hidden')
			const errorText = errorEl.querySelector('p')
			if (errorText) errorText.textContent = message
		}
	}

	function showResult(location: LocationResult) {
		hideLoading()
		document.getElementById('errorMessage')?.classList.add('hidden')

		const resultEl = document.getElementById('locationResult')
		if (resultEl) {
			resultEl.classList.remove('hidden')

			// Update result fields
			const cityEl = document.getElementById('resultCity')
			const countryEl = document.getElementById('resultCountry')
			const latEl = document.getElementById('resultLat')
			const lonEl = document.getElementById('resultLon')

			if (cityEl) cityEl.textContent = location.city
			if (countryEl) countryEl.textContent = location.country
			if (latEl) latEl.textContent = location.lat.toFixed(4)
			if (lonEl) lonEl.textContent = location.lon.toFixed(4)

			// Store coordinates for later use
			const useButton = document.getElementById('useLocationButton')
			if (useButton) {
				useButton.onclick = () => {
					// Call the global loadWeather function instead of navigation
					if (window.loadWeather) {
						window.loadWeather(location.lat, location.lon, location.city)
					} else {
						// Fallback to URL navigation if loadWeather is not available
						window.location.replace(`/?lat=${location.lat}&lon=${location.lon}`)
					}
				}
			}
		}
	}

	// Event listeners
	document.addEventListener('DOMContentLoaded', function () {
		const searchInput = document.getElementById(
			'locationSearch',
		) as HTMLInputElement
		const searchButton = document.getElementById('searchButton')
		const geoButton = document.getElementById('geolocationButton')

		// Search functionality
		async function performSearch() {
			const query = searchInput?.value?.trim()
			if (!query) {
				showError('Please enter a city name')
				return
			}

			showLoading()
			try {
				const location = await searchLocation(query)
				showResult(location)
			} catch (error) {
				showError(error instanceof Error ? error.message : 'Search failed')
			}
		}

		// Search button click
		searchButton?.addEventListener('click', performSearch)

		// Enter key on search input
		searchInput?.addEventListener('keypress', function (e) {
			if (e.key === 'Enter') {
				performSearch()
			}
		})

		// Geolocation button
		geoButton?.addEventListener('click', function () {
			if (!navigator.geolocation) {
				showError('Geolocation is not supported by this browser')
				return
			}

			showLoading()
			navigator.geolocation.getCurrentPosition(
				async function (position) {
					const lat = position.coords.latitude
					const lon = position.coords.longitude

					try {
						const location = await reverseGeocode(lat, lon)
						showResult(location)
					} catch {
						// Even if reverse geocoding fails, we have coordinates
						showResult({
							city: 'Current Location',
							country: 'Unknown',
							lat: lat,
							lon: lon,
							full_name: 'Current Location',
						})
					}
				},
				function (error) {
					let message = 'Failed to get location'
					switch (error.code) {
						case error.PERMISSION_DENIED:
							message = 'Location access denied by user'
							break
						case error.POSITION_UNAVAILABLE:
							message = 'Location information unavailable'
							break
						case error.TIMEOUT:
							message = 'Location request timed out'
							break
					}
					showError(message)
				},
				{
					enableHighAccuracy: true,
					timeout: 10000,
					maximumAge: 300000, // 5 minutes
				},
			)
		})
	})
</script>
